# run scVelo and cellrank

# required preparations: 
# generate the spliced/unspliced loom file using velocyto: https://velocyto.org/velocyto.py/tutorial/cli.html
# 1) download the RepeatMasker track as a GTF from UCSC for hg38 (hg38_repeatmasker.gtf)
# 2) locate the cellranger count output directory and the cellranger reference package
# 3) run the velocyto command line tool:
# velocyto run10x -m hg38_repeatmasker.gtf mypath/cellranger_count_output/ somepath/refdata-gex-GRCh38-2020-A/genes/genes.gtf

import sys
import numpy as np
import pandas as pd
import scvelo as scv
import scanpy as sc
import cellrank as cr
scv.settings.verbosity = 3
scv.settings.set_figure_params("scvelo")
cr.settings.verbosity = 2

# load the data to an AnnData object based on the loom generated by velocyto CLI with repeat masking
adata = scv.read('velocyto_withRepeatMasker.loom', cache=True)
adata.var_names_make_unique()

# load the EC cell barcodes (filtered previously in Seurat) and keep only those cells
barcodes_to_keep = pd.read_csv('./data/EC_cell_barcodes_export_from_Seurat.txt', sep='\t', header=None)[0]
adata = adata[barcodes_to_keep]

# add main EC cluster naming (1-5) exported from Seurat
seurat_clusters = pd.read_csv('./data/Seurat_EC_clusters.txt', sep=' ')
seurat_clusters = pd.array(seurat_clusters['seurat_clusters'], dtype='str')
adata.obs['seurat_clusters'] = seurat_clusters

# add higher resolution (res=0.8) Seurat clusters as well
seurat_clusters_res08 = pd.read_csv('./data/Seurat_EC_clusters_Res08.txt', sep=' ')
seurat_clusters_res08 = pd.array(seurat_clusters_res08['seurat_clusters_res08'], dtype='str')
adata.obs['seurat_clusters_res08'] = seurat_clusters_res08

# add Seurat UMAP coordinates (cells in matching order)
seurat_UMAP_coords = pd.read_csv('./data/Seurat_UMAP.txt', sep=' ')
adata.obsm['X_SeuratUMAP'] = seurat_UMAP_coords.to_numpy()

# standard sc processing
adata.var['mt'] = adata.var_names.str.startswith('MT')
sc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True)
sc.pp.normalize_total(adata, target_sum=1e4)
sc.pp.log1p(adata)
sc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5)
sc.pp.scale(adata, max_value=10)
sc.tl.pca(adata, svd_solver='arpack')
sc.pp.neighbors(adata, n_neighbors=10, n_pcs=30)
sc.tl.umap(adata)
sc.tl.leiden(adata)

# scVelo
scv.pp.filter_genes(adata, min_shared_counts=20)
scv.pp.normalize_per_cell(adata)
scv.pp.filter_genes_dispersion(adata, n_top_genes=5000)
scv.pp.log1p(adata)
scv.pp.moments(adata, n_pcs=30, n_neighbors=30)
scv.tl.velocity(adata)
scv.tl.velocity_graph(adata, n_jobs=10)

# velocity streams
scv.pl.velocity_embedding_stream(adata, basis='SeuratUMAP', density=1, linewidth=1.5, arrow_size=2)

# velocity pseudotime
scv.tl.velocity_pseudotime(adata)
scv.pl.scatter(adata, color='velocity_pseudotime', basis="SeuratUMAP")

# cellrank (based on https://cellrank.readthedocs.io/en/stable/cellrank_basics.html)
scv.pp.filter_and_normalize(adata, min_shared_counts=20, n_top_genes=5000)
sc.tl.pca(adata)
sc.pp.neighbors(adata, n_pcs=30, n_neighbors=30)
scv.pp.moments(adata, n_pcs=None, n_neighbors=None)
# dynamical model from scVelo to estimate the velocities
scv.tl.recover_dynamics(adata, n_jobs=10)
scv.tl.velocity(adata, mode="dynamical")
scv.tl.velocity_graph(adata) 

# streams
scv.pl.velocity_embedding_stream(adata, basis="SeuratUMAP", legend_fontsize=12, title="", smooth=0.8, min_mass=4)

# use cellrank to infer terminal states
cr.tl.terminal_states(adata, cluster_key="seurat_clusters_res08", weight_connectivities=0.2)
cr.pl.terminal_states(adata, basis="SeuratUMAP")

# use cellrank to infer initial states
cr.tl.initial_states(adata, cluster_key="seurat_clusters_res08")
cr.pl.initial_states(adata, discrete=True, basis="SeuratUMAP")
